# üîç –°–∏—Å—Ç–µ–º–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫–∞—Ç–∞–ª–æ–≥–∞

_[‚Üê –ù–∞–∑–∞–¥ –∫ Infinite Scroll](11_CATALOG_INFINITE_SCROLL.md) | [–î–∞–ª–µ–µ: –ü–∞–≥–∏–Ω–∞—Ü–∏—è ‚Üí](13_CATALOG_PAGINATION.md)_

---

## üìã –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤](#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-—Ñ–∏–ª—å—Ç—Ä–æ–≤)
2. [–¢–∏–ø—ã —Ñ–∏–ª—å—Ç—Ä–æ–≤](#—Ç–∏–ø—ã-—Ñ–∏–ª—å—Ç—Ä–æ–≤)
3. [–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º](#—É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ-—Å–æ—Å—Ç–æ—è–Ω–∏–µ–º)
4. [–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å API](#–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è-—Å-api)
5. [–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å](#–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å)
6. [–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å](#–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)

---

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤

### –ü—Ä–∏–Ω—Ü–∏–ø—ã —Ä–∞–±–æ—Ç—ã

–°–∏—Å—Ç–µ–º–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∞ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏—Ö –ø—Ä–∏–Ω—Ü–∏–ø–∞—Ö:

1. **–†–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å** - –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ª—é–±–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
2. **–ö–æ–º–ø–æ–∑–∏—Ç–Ω–æ—Å—Ç—å** - —Ñ–∏–ª—å—Ç—Ä—ã –º–æ–∂–Ω–æ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å –ª—é–±—ã–º —Å–ø–æ—Å–æ–±–æ–º
3. **–ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å** - —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ URL
4. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –¥–µ–±–∞—É–Ω—Å–∏–Ω–≥ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤

```javascript
/**
 * –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤
 */
const filterConfig = {
  category: {
    type: "select",
    apiParam: "category",
    defaultValue: null,
    label: "–ñ–∞–Ω—Ä",
    options: [], // –ó–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
  },

  price: {
    type: "select",
    apiParam: ["minPrice", "maxPrice"],
    defaultValue: "all",
    label: "–¶–µ–Ω–∞",
    options: [
      { value: "all", label: "–õ—é–±–∞—è —Ü–µ–Ω–∞", min: null, max: null },
      { value: "low", label: "–î–æ 1000 —Ä—É–±.", min: 0, max: 1000 },
      { value: "medium", label: "1000-2000 —Ä—É–±.", min: 1000, max: 2000 },
      { value: "high", label: "–û—Ç 2000 —Ä—É–±.", min: 2000, max: null },
    ],
  },

  authorType: {
    type: "select",
    apiParam: "authorType",
    defaultValue: "all",
    label: "–¢–∏–ø –∞–≤—Ç–æ—Ä–∞",
    options: [
      { value: "all", label: "–í—Å–µ –∞–≤—Ç–æ—Ä—ã" },
      { value: "russian", label: "–†—É—Å—Å–∫–∏–µ –∞–≤—Ç–æ—Ä—ã" },
      { value: "foreign", label: "–ó–∞—Ä—É–±–µ–∂–Ω—ã–µ –∞–≤—Ç–æ—Ä—ã" },
    ],
  },
};
```

---

## üéõÔ∏è –¢–∏–ø—ã —Ñ–∏–ª—å—Ç—Ä–æ–≤

### –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º

#### HTML —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

```html
<div class="filter-group">
  <label for="category-select">–ñ–∞–Ω—Ä:</label>
  <select id="category-select" class="filter-select">
    <option value="">–í—Å–µ –∂–∞–Ω—Ä—ã</option>
    <!-- –û–ø—Ü–∏–∏ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
  </select>
</div>
```

#### JavaScript –ª–æ–≥–∏–∫–∞

```javascript
/**
 * Load and render category filter
 */
async function initCategoryFilter() {
  try {
    console.log("Initializing category filter...");

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Å —Å–µ—Ä–≤–µ—Ä–∞
    const categories = await fetchCategories();

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    state.categories = categories;

    // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä–µ
    renderCategoryOptions(categories);

    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    setupCategoryEventListeners();

    console.log(
      `Category filter initialized with ${categories.length} options`
    );
  } catch (error) {
    console.error("Error initializing category filter:", error);
    renderCategoryError();
  }
}

/**
 * Fetch categories from API
 */
async function fetchCategories() {
  const response = await fetch("/api/categories?limit=100");

  if (!response.ok) {
    throw new Error(`Failed to fetch categories: ${response.status}`);
  }

  const data = await response.json();

  if (!data.success || !data.data.categories) {
    throw new Error("Invalid categories response format");
  }

  return data.data.categories;
}

/**
 * Render category options in select
 */
function renderCategoryOptions(categories) {
  const select = document.getElementById("category-select");
  if (!select) return;

  // –û—á–∏—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –æ–ø—Ü–∏–∏ (–∫—Ä–æ–º–µ –ø–µ—Ä–≤–æ–π)
  while (select.children.length > 1) {
    select.removeChild(select.lastChild);
  }

  // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
  categories.forEach((category) => {
    const option = document.createElement("option");
    option.value = category.id;
    option.textContent = escapeHtml(category.name);
    option.dataset.categoryId = category.id;
    select.appendChild(option);
  });
}

/**
 * Setup category filter event listeners
 */
function setupCategoryEventListeners() {
  const select = document.getElementById("category-select");
  if (!select) return;

  select.addEventListener("change", (e) => {
    const categoryId = e.target.value || null;
    updateCategoryFilter(categoryId);
  });
}

/**
 * Update category filter
 */
function updateCategoryFilter(categoryId) {
  if (state.filters.category !== categoryId) {
    console.log("Category filter changed:", categoryId);

    state.filters.category = categoryId;
    resetToFirstPage();
    applyFilters();

    // –ê–Ω–∞–ª–∏—Ç–∏–∫–∞
    trackEvent("filter_category_changed", {
      category_id: categoryId,
      category_name: getCategoryName(categoryId),
    });
  }
}

/**
 * Get category name by ID
 */
function getCategoryName(categoryId) {
  if (!categoryId) return "–í—Å–µ –∂–∞–Ω—Ä—ã";

  const category = state.categories.find((cat) => cat.id == categoryId);
  return category ? category.name : "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∂–∞–Ω—Ä";
}
```

### –§–∏–ª—å—Ç—Ä –ø–æ —Ü–µ–Ω–µ

#### HTML —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

```html
<div class="filter-group">
  <label for="price-select">–¶–µ–Ω–∞:</label>
  <select id="price-select" class="filter-select">
    <option value="all">–õ—é–±–∞—è —Ü–µ–Ω–∞</option>
    <option value="low">–î–æ 1000 —Ä—É–±.</option>
    <option value="medium">1000-2000 —Ä—É–±.</option>
    <option value="high">–û—Ç 2000 —Ä—É–±.</option>
  </select>
</div>
```

#### JavaScript –ª–æ–≥–∏–∫–∞

```javascript
/**
 * Initialize price filter
 */
function initPriceFilter() {
  const select = document.getElementById("price-select");
  if (!select) return;

  select.addEventListener("change", (e) => {
    const priceRange = e.target.value;
    updatePriceFilter(priceRange);
  });

  console.log("Price filter initialized");
}

/**
 * Update price filter
 */
function updatePriceFilter(priceRange) {
  const priceConfig = filterConfig.price.options.find(
    (opt) => opt.value === priceRange
  );

  if (priceConfig) {
    const newMinPrice = priceConfig.min;
    const newMaxPrice = priceConfig.max;

    if (
      state.filters.minPrice !== newMinPrice ||
      state.filters.maxPrice !== newMaxPrice
    ) {
      console.log("Price filter changed:", {
        priceRange,
        min: newMinPrice,
        max: newMaxPrice,
      });

      state.filters.minPrice = newMinPrice;
      state.filters.maxPrice = newMaxPrice;
      resetToFirstPage();
      applyFilters();

      // –ê–Ω–∞–ª–∏—Ç–∏–∫–∞
      trackEvent("filter_price_changed", {
        price_range: priceRange,
        min_price: newMinPrice,
        max_price: newMaxPrice,
      });
    }
  }
}

/**
 * Get current price range label
 */
function getCurrentPriceRangeLabel() {
  const { minPrice, maxPrice } = state.filters;

  if (minPrice === null && maxPrice === null) {
    return "–õ—é–±–∞—è —Ü–µ–Ω–∞";
  }

  const option = filterConfig.price.options.find(
    (opt) => opt.min === minPrice && opt.max === maxPrice
  );

  return option ? option.label : "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω";
}
```

### –§–∏–ª—å—Ç—Ä –ø–æ —Ç–∏–ø—É –∞–≤—Ç–æ—Ä–∞

#### HTML —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

```html
<div class="filter-group">
  <label for="author-type-select">–¢–∏–ø –∞–≤—Ç–æ—Ä–∞:</label>
  <select id="author-type-select" class="filter-select">
    <option value="all">–í—Å–µ –∞–≤—Ç–æ—Ä—ã</option>
    <option value="russian">–†—É—Å—Å–∫–∏–µ –∞–≤—Ç–æ—Ä—ã</option>
    <option value="foreign">–ó–∞—Ä—É–±–µ–∂–Ω—ã–µ –∞–≤—Ç–æ—Ä—ã</option>
  </select>
</div>
```

#### JavaScript –ª–æ–≥–∏–∫–∞

```javascript
/**
 * Initialize author type filter
 */
function initAuthorTypeFilter() {
  const select = document.getElementById("author-type-select");
  if (!select) return;

  select.addEventListener("change", (e) => {
    const authorType = e.target.value === "all" ? null : e.target.value;
    updateAuthorTypeFilter(authorType);
  });

  console.log("Author type filter initialized");
}

/**
 * Update author type filter
 */
function updateAuthorTypeFilter(authorType) {
  if (state.filters.authorType !== authorType) {
    console.log("Author type filter changed:", authorType);

    state.filters.authorType = authorType;
    resetToFirstPage();
    applyFilters();

    // –ê–Ω–∞–ª–∏—Ç–∏–∫–∞
    trackEvent("filter_author_type_changed", {
      author_type: authorType || "all",
    });
  }
}
```

---

## üóÇÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º

### –û—Å–Ω–æ–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤

```javascript
/**
 * Filter state management
 */
const filterState = {
  /**
   * Get active filters (non-null values)
   */
  getActiveFilters() {
    const active = {};

    Object.entries(state.filters).forEach(([key, value]) => {
      if (value !== null && value !== undefined) {
        active[key] = value;
      }
    });

    return active;
  },

  /**
   * Get filters for API request
   */
  getAPIFilters() {
    const apiFilters = {};

    // –ö–∞—Ç–µ–≥–æ—Ä–∏—è
    if (state.filters.category) {
      apiFilters.category = state.filters.category;
    }

    // –¶–µ–Ω–∞
    if (state.filters.minPrice !== null) {
      apiFilters.minPrice = state.filters.minPrice;
    }
    if (state.filters.maxPrice !== null) {
      apiFilters.maxPrice = state.filters.maxPrice;
    }

    // –¢–∏–ø –∞–≤—Ç–æ—Ä–∞
    if (state.filters.authorType) {
      apiFilters.authorType = state.filters.authorType;
    }

    return apiFilters;
  },

  /**
   * Check if any filters are active
   */
  hasActiveFilters() {
    return Object.keys(this.getActiveFilters()).length > 0;
  },

  /**
   * Reset all filters to default values
   */
  resetAll() {
    state.filters = {
      category: null,
      minPrice: null,
      maxPrice: null,
      authorType: null,
    };

    this.updateUI();
  },

  /**
   * Update UI to reflect current filter state
   */
  updateUI() {
    // –ö–∞—Ç–µ–≥–æ—Ä–∏—è
    const categorySelect = document.getElementById("category-select");
    if (categorySelect) {
      categorySelect.value = state.filters.category || "";
    }

    // –¶–µ–Ω–∞
    const priceSelect = document.getElementById("price-select");
    if (priceSelect) {
      priceSelect.value = this.getPriceSelectValue();
    }

    // –¢–∏–ø –∞–≤—Ç–æ—Ä–∞
    const authorTypeSelect = document.getElementById("author-type-select");
    if (authorTypeSelect) {
      authorTypeSelect.value = state.filters.authorType || "all";
    }
  },

  /**
   * Get price select value based on current min/max
   */
  getPriceSelectValue() {
    const { minPrice, maxPrice } = state.filters;

    const option = filterConfig.price.options.find(
      (opt) => opt.min === minPrice && opt.max === maxPrice
    );

    return option ? option.value : "all";
  },

  /**
   * Validate filter values
   */
  validate() {
    const errors = [];

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é
    if (
      state.filters.category &&
      !state.categories.find((cat) => cat.id == state.filters.category)
    ) {
      errors.push("Invalid category ID");
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ü–µ–Ω—É
    if (
      state.filters.minPrice !== null &&
      (state.filters.minPrice < 0 || state.filters.minPrice > 100000)
    ) {
      errors.push("Invalid min price range");
    }

    if (
      state.filters.maxPrice !== null &&
      (state.filters.maxPrice < 0 || state.filters.maxPrice > 100000)
    ) {
      errors.push("Invalid max price range");
    }

    if (
      state.filters.minPrice !== null &&
      state.filters.maxPrice !== null &&
      state.filters.minPrice > state.filters.maxPrice
    ) {
      errors.push("Min price cannot be greater than max price");
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –∞–≤—Ç–æ—Ä–∞
    if (
      state.filters.authorType &&
      !["russian", "foreign"].includes(state.filters.authorType)
    ) {
      errors.push("Invalid author type");
    }

    return errors;
  },
};
```

### URL –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å

```javascript
/**
 * URL state management for filters
 */
const urlState = {
  /**
   * Save current filters to URL
   */
  saveToURL() {
    const url = new URL(window.location);
    const params = url.searchParams;

    // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–∏–ª—å—Ç—Ä–æ–≤
    this.clearFilterParams(params);

    // –î–æ–±–∞–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
    const activeFilters = filterState.getActiveFilters();

    Object.entries(activeFilters).forEach(([key, value]) => {
      if (value !== null && value !== undefined) {
        params.set(key, value);
      }
    });

    // –û–±–Ω–æ–≤–ª—è–µ–º URL –±–µ–∑ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    window.history.replaceState({}, "", url);
  },

  /**
   * Load filters from URL
   */
  loadFromURL() {
    const params = new URLSearchParams(window.location.search);

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const urlFilters = {
      category: params.get("category") || null,
      minPrice: params.get("minPrice")
        ? parseInt(params.get("minPrice"))
        : null,
      maxPrice: params.get("maxPrice")
        ? parseInt(params.get("maxPrice"))
        : null,
      authorType: params.get("authorType") || null,
    };

    // –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º
    if (this.validateURLFilters(urlFilters)) {
      state.filters = urlFilters;
      filterState.updateUI();
      return true;
    }

    return false;
  },

  /**
   * Clear filter parameters from URLSearchParams
   */
  clearFilterParams(params) {
    ["category", "minPrice", "maxPrice", "authorType"].forEach((key) => {
      params.delete(key);
    });
  },

  /**
   * Validate filters loaded from URL
   */
  validateURLFilters(filters) {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    const originalFilters = { ...state.filters };

    // –í—Ä–µ–º–µ–Ω–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
    state.filters = filters;

    // –í–∞–ª–∏–¥–∏—Ä—É–µ–º
    const errors = filterState.validate();

    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    state.filters = originalFilters;

    if (errors.length > 0) {
      console.warn("Invalid URL filters:", errors);
      return false;
    }

    return true;
  },
};
```

---

## üì° –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å API

### –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∑–∞–ø—Ä–æ—Å–∞

```javascript
/**
 * Build API request parameters including filters
 */
function buildAPIParams() {
  const params = new URLSearchParams();

  // –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
  params.append("page", state.currentPage);
  params.append("limit", state.itemsPerPage);
  params.append("sortBy", "popularity");
  params.append("sortOrder", "DESC");

  // –§–∏–ª—å—Ç—Ä—ã
  const apiFilters = filterState.getAPIFilters();

  Object.entries(apiFilters).forEach(([key, value]) => {
    if (value !== null && value !== undefined) {
      params.append(key, value);
    }
  });

  return params;
}

/**
 * Apply filters by reloading data
 */
async function applyFilters() {
  console.log("Applying filters...", filterState.getActiveFilters());

  try {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ URL
    urlState.saveToURL();

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤
    updateActiveFiltersCounter();

    // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    if (state.infiniteScrollMode) {
      // –í —Ä–µ–∂–∏–º–µ infinite scroll —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      resetInfiniteScrollState();
      await loadBooksInfiniteScroll();
    } else {
      // –í —Ä–µ–∂–∏–º–µ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –∑–∞–≥—Ä—É–∂–∞–µ–º –∑–∞–Ω–æ–≤–æ
      await loadBooks();
    }

    // –ê–Ω–∞–ª–∏—Ç–∏–∫–∞
    trackFilterUsage();
  } catch (error) {
    console.error("Error applying filters:", error);
    showNotification("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤", "error");
  }
}

/**
 * Track filter usage analytics
 */
function trackFilterUsage() {
  const activeFilters = filterState.getActiveFilters();

  trackEvent("filters_applied", {
    filters_count: Object.keys(activeFilters).length,
    has_category: !!activeFilters.category,
    has_price: !!(
      activeFilters.minPrice !== undefined ||
      activeFilters.maxPrice !== undefined
    ),
    has_author_type: !!activeFilters.authorType,
    filter_combination: Object.keys(activeFilters).sort().join(","),
  });
}
```

### –î–µ–±–∞—É–Ω—Å–∏–Ω–≥ –∑–∞–ø—Ä–æ—Å–æ–≤

```javascript
/**
 * Debounced filter application
 */
const debouncedApplyFilters = debounce(applyFilters, 300);

/**
 * Apply filters with debouncing
 */
function applyFiltersDebounced() {
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏
  showFilterLoading();

  // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
  debouncedApplyFilters();
}

/**
 * Show filter loading state
 */
function showFilterLoading() {
  const filtersRow = document.querySelector(".filters-row");
  if (filtersRow) {
    filtersRow.classList.add("loading");
  }
}

/**
 * Hide filter loading state
 */
function hideFilterLoading() {
  const filtersRow = document.querySelector(".filters-row");
  if (filtersRow) {
    filtersRow.classList.remove("loading");
  }
}
```

---

## üé® –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å

### –°—á–µ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤

```javascript
/**
 * Update active filters counter
 */
function updateActiveFiltersCounter() {
  const counter = document.getElementById("active-filters-counter");
  if (!counter) return;

  const activeCount = Object.keys(filterState.getActiveFilters()).length;

  if (activeCount > 0) {
    counter.textContent = activeCount;
    counter.style.display = "inline-block";
    counter.classList.add("has-filters");
  } else {
    counter.style.display = "none";
    counter.classList.remove("has-filters");
  }
}
```

#### HTML –¥–ª—è —Å—á–µ—Ç—á–∏–∫–∞

```html
<div class="filters-header">
  <h3>
    –§–∏–ª—å—Ç—Ä—ã
    <span
      id="active-filters-counter"
      class="filters-counter"
      style="display: none;"
      >0</span
    >
  </h3>
  <button id="reset-filters-btn" class="btn-reset" onclick="resetAllFilters()">
    –°–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ
  </button>
</div>
```

#### CSS –¥–ª—è —Å—á–µ—Ç—á–∏–∫–∞

```css
.filters-counter {
  background: #e74c3c;
  color: white;
  border-radius: 50%;
  padding: 2px 6px;
  font-size: 0.75em;
  font-weight: bold;
  margin-left: 5px;
}

.filters-counter.has-filters {
  animation: pulse 0.3s ease-in-out;
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}
```

### –ö–Ω–æ–ø–∫–∞ —Å–±—Ä–æ—Å–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤

```javascript
/**
 * Reset all filters
 */
window.resetAllFilters = function () {
  console.log("Resetting all filters...");

  // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  filterState.resetAll();

  // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
  resetToFirstPage();

  // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
  applyFilters();

  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
  showNotification("–§–∏–ª—å—Ç—Ä—ã —Å–±—Ä–æ—à–µ–Ω—ã", "info");

  // –ê–Ω–∞–ª–∏—Ç–∏–∫–∞
  trackEvent("filters_reset", {
    previous_filters_count: Object.keys(filterState.getActiveFilters()).length,
  });
};

/**
 * Update reset button visibility
 */
function updateResetButtonVisibility() {
  const resetBtn = document.getElementById("reset-filters-btn");
  if (!resetBtn) return;

  const hasActiveFilters = filterState.hasActiveFilters();
  resetBtn.style.display = hasActiveFilters ? "inline-block" : "none";
}
```

### –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å

```javascript
/**
 * Add visual feedback for filter changes
 */
function addFilterChangeAnimation(selectElement) {
  if (!selectElement) return;

  selectElement.classList.add("filter-changed");

  setTimeout(() => {
    selectElement.classList.remove("filter-changed");
  }, 300);
}

/**
 * Show filter results summary
 */
function showFilterResultsSummary() {
  const summary = document.getElementById("filter-results-summary");
  if (!summary) return;

  const activeFilters = filterState.getActiveFilters();
  const filtersCount = Object.keys(activeFilters).length;

  if (filtersCount > 0) {
    const filtersText = generateFiltersText(activeFilters);
    summary.innerHTML = `
            <div class="filters-summary">
                <strong>–ü—Ä–∏–º–µ–Ω–µ–Ω—ã —Ñ–∏–ª—å—Ç—Ä—ã:</strong> ${filtersText}
                <button onclick="resetAllFilters()" class="btn-link">–°–±—Ä–æ—Å–∏—Ç—å</button>
            </div>
        `;
    summary.style.display = "block";
  } else {
    summary.style.display = "none";
  }
}

/**
 * Generate human-readable filters text
 */
function generateFiltersText(activeFilters) {
  const parts = [];

  if (activeFilters.category) {
    const categoryName = getCategoryName(activeFilters.category);
    parts.push(`–∂–∞–Ω—Ä "${categoryName}"`);
  }

  if (
    activeFilters.minPrice !== undefined ||
    activeFilters.maxPrice !== undefined
  ) {
    const priceText = getCurrentPriceRangeLabel();
    parts.push(`—Ü–µ–Ω–∞ "${priceText}"`);
  }

  if (activeFilters.authorType) {
    const authorTypeText =
      activeFilters.authorType === "russian"
        ? "—Ä—É—Å—Å–∫–∏–µ –∞–≤—Ç–æ—Ä—ã"
        : "–∑–∞—Ä—É–±–µ–∂–Ω—ã–µ –∞–≤—Ç–æ—Ä—ã";
    parts.push(authorTypeText);
  }

  return parts.join(", ");
}
```

---

## ‚ö° –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

### –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤

```javascript
/**
 * Cache for filter-related data
 */
const filterCache = {
  categories: null,
  categoriesFetchTime: null,

  /**
   * Get categories with caching
   */
  async getCategories() {
    const now = Date.now();
    const cacheTimeout = 5 * 60 * 1000; // 5 –º–∏–Ω—É—Ç

    if (
      this.categories &&
      this.categoriesFetchTime &&
      now - this.categoriesFetchTime < cacheTimeout
    ) {
      return this.categories;
    }

    try {
      this.categories = await fetchCategories();
      this.categoriesFetchTime = now;
      return this.categories;
    } catch (error) {
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –µ—Å—Ç—å
      if (this.categories) {
        console.warn("Using cached categories due to fetch error");
        return this.categories;
      }
      throw error;
    }
  },

  /**
   * Clear cache
   */
  clear() {
    this.categories = null;
    this.categoriesFetchTime = null;
  },
};
```

### –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö

```javascript
/**
 * Preload filter data
 */
async function preloadFilterData() {
  try {
    console.log("Preloading filter data...");

    // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∂–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    await filterCache.getCategories();

    console.log("Filter data preloaded successfully");
  } catch (error) {
    console.warn("Failed to preload filter data:", error);
  }
}

/**
 * Initialize filters with preloaded data
 */
async function initFiltersWithPreload() {
  // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫—É
  const preloadPromise = preloadFilterData();

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∞–∑–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
  setupBasicFilterStructure();

  // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∏
  await preloadPromise;

  // –ó–∞–≤–µ—Ä—à–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
  finishFilterInitialization();
}
```

### –ú–µ–º–æ–∏–∑–∞—Ü–∏—è

```javascript
/**
 * Memoized filter functions
 */
const memoizedFilters = {
  cache: new Map(),

  /**
   * Memoized filter application
   */
  applyFilters: (() => {
    const cache = new Map();

    return (filters) => {
      const key = JSON.stringify(filters);

      if (cache.has(key)) {
        console.log("Using memoized filter result");
        return cache.get(key);
      }

      const result = this.actualApplyFilters(filters);
      cache.set(key, result);

      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∫–µ—à–∞
      if (cache.size > 10) {
        const firstKey = cache.keys().next().value;
        cache.delete(firstKey);
      }

      return result;
    };
  })(),

  /**
   * Clear memoization cache
   */
  clearCache() {
    this.cache.clear();
  },
};
```

---

_[‚Üê –ù–∞–∑–∞–¥ –∫ Infinite Scroll](11_CATALOG_INFINITE_SCROLL.md) | [–î–∞–ª–µ–µ: –ü–∞–≥–∏–Ω–∞—Ü–∏—è ‚Üí](13_CATALOG_PAGINATION.md)_
